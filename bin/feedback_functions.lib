#!/bin/bash
# Trival slightly-formatted print wrappers.
# For these to be useful, this lib should be included by source-ing it.
# source "$(dirname "$(readlink -f "$0")")/feedback_functions.lib"

# Define ANSI color codes as constants
COLOR_RESET="\033[0m"
COLOR_GRAY="\033[90m"
COLOR_LIGHT_BLUE="\033[94m"
COLOR_GREEN="\033[1;32m"
COLOR_YELLOW="\033[1;33m"
COLOR_RED="\033[1;31m"
COLOR_BRIGHT_GREEN="\033[92m"
COLOR_BRIGHT_WHITE="\033[97m"

LOGLEVEL_TRACE=8
LOGLEVEL_DEBUG=7
LOGLEVEL_INFO=6
LOGLEVEL_NOTICE=5
LOGLEVEL_WARNING=4
LOGLEVEL_ERROR=3
LOGLEVEL_SUCCESS=0

exit_code=0;
exit_error=1
exit_warning=2
exit_access_error=4
exit_content_error=8

export LOGLEVEL=${LOGLEVEL:-$LOGLEVEL_INFO}
export ADD_SOURCE_TO_MESSAGES=${ADD_SOURCE_TO_MESSAGES:-""}

# Generalized log function
# Can accept input as either an arg or piped.
log_message() {
  local level=$1
  shift 1
  case "$level" in
    "$LOGLEVEL_TRACE")
      color=${COLOR_GRAY}
      label="TRACE"
      ;;
    "$LOGLEVEL_DEBUG")
      color=${COLOR_GRAY}
      label="DEBUG"
      ;;
    "$LOGLEVEL_NOTICE")
      color=${COLOR_LIGHT_BLUE}
      label="NOTICE"
      ;;
    "$LOGLEVEL_INFO")
      color=${COLOR_GREEN}
      label="INFO"
      ;;
    "$LOGLEVEL_WARNING")
      color=${COLOR_YELLOW}
      label="WARNING"
      ;;
    "$LOGLEVEL_ERROR")
      color=${COLOR_RED}
      label="ERROR"
      ;;
    "$LOGLEVEL_SUCCESS")
      color=${COLOR_BRIGHT_GREEN}
      label="SUCCESS"
      ;;
    *)
      color=${COLOR_RESET}
      log_warning "No level set for ${FUNCNAME[0]} ?"
      level=0
      ;; # Default case, no color
  esac

  if [ -n "$ADD_SOURCE_TO_MESSAGES" ]; then
    prefix="${COLOR_GRAY}# ($(basename $0)) #${COLOR_RESET} "
  else
    prefix=""; # [$label]"
  fi

  if [ "$LOGLEVEL" -ge "$level" ]; then
    if [ ! -t 0 ]; then
      # Handle piped input
      while IFS= read -r line; do
        echo -e "$prefix ${color}$line${COLOR_RESET}" >&2
      done
    else
      # Handle inline arguments
      echo -e "$prefix ${color}$*${COLOR_RESET}" >&2
    fi
  fi
}

log_trace() { log_message $LOGLEVEL_TRACE "$*"; }
log_debug() { log_message $LOGLEVEL_DEBUG "$*"; }
log_info() { log_message $LOGLEVEL_INFO "$*"; }
log_notice() { log_message $LOGLEVEL_NOTICE "$*"; }
log_warning() { log_message $LOGLEVEL_WARNING "$*"; }
log_error() { log_message $LOGLEVEL_ERROR "$*"; }
log_success() { log_message $LOGLEVEL_SUCCESS "$*"; }

print_err() { >&2 echo -e "$@"; }
print_log() {
  # Old alias, deprecate.
  log_notice "$@"
}
add_source() {
  prefix="${COLOR_GRAY}# ($(basename $0)) #${COLOR_RESET} "
  echo "$prefix $@";
}

log_indent() {
  indent "$@"
}

log_function_call() {
  echo -e ">  \033[0;97;46m${FUNCNAME[1]} \033[0;94;46m$@\033[0m" >&2
}

indent() {
  local prefix="    "
  if [ "$#" -eq 0 ]; then
    sed "s/^/${prefix}/"
  else
    printf "%s\n" "$@" | sed "s/^/${prefix}/"
  fi
}

format_keyval() {
  local key=$1
  local value=$2
  echo -e "${COLOR_LIGHT_BLUE}${key}:${COLOR_RESET}\n$(indent "$value")"
}


# A wrapper to run commands, formatting both stout and sdterr,
# return value and return code should still be passed back to the caller context.

run_command() {
    log_notice "Running command: \033[97;40m$*\033[0m"
    local exit_code
    # Set a narrower width for the child process
    # So it doesn't look like ass after I add a prefix.
    local original_columns=$COLUMNS
    export COLUMNS=80

    # Respect the STDERR and STDOUT that the callee used.
    { "$@" > >(log_debug) 2> >(log_trace >&2); }
    exit_code=$?

    # Restore original width if it was set
    if [ -n "$original_columns" ]; then
        export COLUMNS=$original_columns
    else
        unset COLUMNS
    fi

    return $exit_code
}

# Use this version if running a command using pipes or subshells.
#   run_command_quoted "cat \"INPUTFILE\" > \"OUTPUTFILE\""
run_command_quoted() {
    local command_string="$1"
    shift
    log_info "Running command: \033[97;40m$command_string\033[0m"
    local output
    local exit_code
    output=$(eval "$command_string" 2> >(log_notice >&2) )
    log_info <<< "$output"
    exit_code=$?
    return $exit_code
}

# Verifies that some pre-requisite variables have already been set in the current scope.
# The expected variables are either pre-declared in a REQUIRED_PARAMETERS array,
# or passed as arguments to the function.
# When an expected variable is found, it is logged.
# if an required variable is unset or empty, raise an error.
#
# Usage:
#
# SOURCE_PROJECTID=gfdsar
# SOURCE_BRANCH=''
# REQUIRED_PARAMETERS=( SOURCE_PROJECTID SOURCE_BRANCH )
# check_required_parameters_are_set
# > SOURCE_PROJECTID=gfdsar
# > SOURCE_BRANCH is required, but is currently blank
#
check_required_parameters_are_set() {
    local parameters=("${REQUIRED_PARAMETERS[@]}")
    if [[ $# -gt 0 ]]; then
      parameters=("$@")
    fi
    for varname in "${parameters[@]}"; do
        local value
        eval value=\$"${varname}"
        if [[ -z $value ]]; then
            log_error "$varname is required, but is currently blank" >&2
            # Error 21 : One or more arguments are missing.
            return 21
        else
            log_info "$COLOR_BRIGHT_WHITE export $varname=$value $COLOR_RESET "
        fi
    done
    return 0
}

get_project_id_from_context() {
  export PLATFORM_PROJECT="${1:-${PLATFORM_PROJECT:-$(platform --no project:info id)}}"
}

# Make these util funcs available to the sub processes.
export -f log_message  print_err run_command
export -f log_debug log_info log_notice log_warning log_error log_indent










test_feedback_functions() {
  # Define semantic labels for colors
  local COLOR_LABEL="${COLOR_YELLOW}"
  local COLOR_FUNCTION="${COLOR_GREEN}"
  local COLOR_ARGS="${COLOR_GRAY}"

  echo -e "${COLOR_LIGHT_BLUE}Testing feedback functions...${COLOR_RESET}"

  # log_debug
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}log_debug${COLOR_RESET} ${COLOR_ARGS}\"Debug message\"${COLOR_RESET}"
  log_debug "Debug message"
  echo -e "${COLOR_LABEL}Function piped:${COLOR_RESET} ${COLOR_ARGS}echo \"Piped debug message\" | ${COLOR_FUNCTION}log_debug${COLOR_RESET}"
  echo "Piped debug message" | log_debug
  echo

  # log_info
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}log_info${COLOR_RESET} ${COLOR_ARGS}\"Info message\"${COLOR_RESET}"
  log_info "Info message"
  echo -e "${COLOR_LABEL}Function piped:${COLOR_RESET} ${COLOR_ARGS}echo \"Piped info message\" | ${COLOR_FUNCTION}log_info${COLOR_RESET}"
  echo "Piped info message" | log_info
  echo

  # log_notice
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}log_notice${COLOR_RESET} ${COLOR_ARGS}\"Notice message\"${COLOR_RESET}"
  log_notice "Notice message"
  echo -e "${COLOR_LABEL}Function piped:${COLOR_RESET} ${COLOR_ARGS}echo \"Piped notice message\" | ${COLOR_FUNCTION}log_notice${COLOR_RESET}"
  echo "Piped notice message" | log_notice
  echo

  # log_warning
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}log_warning${COLOR_RESET} ${COLOR_ARGS}\"Warning message\"${COLOR_RESET}"
  log_warning "Warning message"
  echo -e "${COLOR_LABEL}Function piped:${COLOR_RESET} ${COLOR_ARGS}echo \"Piped warning message\" | ${COLOR_FUNCTION}log_warning${COLOR_RESET}"
  echo "Piped warning message" | log_warning
  echo

  # log_error
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}log_error${COLOR_RESET} ${COLOR_ARGS}\"Error message\"${COLOR_RESET}"
  log_error "Error message"
  echo -e "${COLOR_LABEL}Function piped:${COLOR_RESET} ${COLOR_ARGS}echo \"Piped error message\" | ${COLOR_FUNCTION}log_error${COLOR_RESET}"
  echo "Piped error message" | log_error
  echo

  # print_err
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}print_err${COLOR_RESET} ${COLOR_ARGS}\"Error message\"${COLOR_RESET}"
  print_err "Error message"
  echo

  # log_message
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}log_message${COLOR_RESET} ${COLOR_ARGS}\"Log message\"${COLOR_RESET}"
  log_message 0 "Log message"
  echo

  # add_source
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}add_source${COLOR_RESET} ${COLOR_ARGS}\"Source message\"${COLOR_RESET}"
  add_source "Source message"
  echo

  # log_indent
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}log_indent${COLOR_RESET} ${COLOR_ARGS}\"Indented message\"${COLOR_RESET}"
  log_indent "Indented message"
  echo -e "${COLOR_LABEL}Function piped:${COLOR_RESET} ${COLOR_ARGS}echo \"Piped indented message\" | ${COLOR_FUNCTION}log_indent${COLOR_RESET}"
  echo "Piped indented message" | log_indent
  echo

  # log_function_call
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}log_function_call${COLOR_RESET} ${COLOR_ARGS}\"Function arguments\"${COLOR_RESET}"
  log_function_call "Function arguments"
  echo


  # indent
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}indent${COLOR_RESET} ${COLOR_ARGS}\"Indented text\"${COLOR_RESET}"
  indent "Indented text"
  echo -e "${COLOR_LABEL}Function piped:${COLOR_RESET} ${COLOR_ARGS}echo \"Piped indented text\" | indent${COLOR_RESET}"
  echo "Piped indented text" | indent
  echo

  # format_keyval
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}format_keyval${COLOR_RESET} ${COLOR_ARGS}\"Key\" \"Value\"${COLOR_RESET}"
  format_keyval "Key" "Value"
  echo

  # run_command
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}run_command${COLOR_RESET} ${COLOR_ARGS}ls${COLOR_RESET}"
  run_command ls
  echo

  # run_command_quoted
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}run_command_quoted${COLOR_RESET} ${COLOR_ARGS}\"echo 'Quoted command'\"${COLOR_RESET}"
  run_command_quoted "echo 'Quoted command'"
  echo

  # check_required_parameters_are_set
  export REQUIRED_PARAMETERS=( TEST_VAR TEST_KEY )
  echo -e "${COLOR_LABEL}Function:${COLOR_RESET} ${COLOR_FUNCTION}check_required_parameters_are_set${COLOR_RESET} ${COLOR_ARGS}TEST_VAR TEST_KEY${COLOR_RESET}"
  export TEST_VAR="Test value"
  check_required_parameters_are_set "TEST_VAR" "TEST_KEY"
  echo
}
# Call the test function
# test_feedback_functions
