#!/usr/bin/env bash
# Wrapper for small checks, to provide consistent logging and audit reporting.
#
# Usage: check $check_name
#
# All checks will return:
# Status code, as returned by the command.
# MAY return some STDOUT, which is s useful value,
# MAY return some STDERR which is just logging.
#
# In addition, the check will log its result to an SQLite database
# for later reporting or auditing.
#
# Architecture:
# No arguments are passed to checks.
# Each named check file declares the environment variables it expects to have present.
# It is the check harnes (thif wrapper) that validates that those variables are set.
#
# Checks can also be used as Gherkin steps, so they declare metadata for that purpose.
# A check may declare a CHECK_ID, CHECK_DESCRIPTION, CHECK_RETURN_VARNAME,
# and a CHECK_WHEN (for Gherkin matching).
# These may be leveraged by a Gherkin runner - a different process from this one,
# but one that can share the same configs.

# Source the util library relative to this script's location
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../feedback_functions.lib"
source "$SCRIPT_DIR/../audit_reporting.lib"
PLATFORM_CLI=${PLATFORM_CLI:-platform}
exit_code=0;

source "$SCRIPT_DIR/$1" || ( log_error "Invalid check. could not source $1" && exit 1 )

log_notice "Running check: \033[97;40m$(basename $1)\033[0m "
log_notice "$CHECK_DESCRIPTION"

check_required_parameters_are_set || exit $?

# If the check explicitly published what its check process was, show that.
log_notice "$literal_check_command"

# This evaluation of the `check` command needs to capture the
# STDOUT, STERR and return code, and log them each
# into the audit_reporting_set_check
set +e
TMPLOG=$(mktemp)
OUTPUT=$(check 2>"$TMPLOG")
STATUS_CODE=$?
LOG=$(cat "$TMPLOG")
rm "$TMPLOG"
set -e

STATUS_TEXT=$(audit_status_code_to_text $STATUS_CODE)
audit_report_result "$CHECK_ID" "$STATUS_TEXT" "$OUTPUT" "$LOG"

echo "$OUTPUT"
exit $STATUS_CODE;
