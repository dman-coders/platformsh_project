<?php

/**
 * @file
 * Install, update and uninstall functions for the platformsh_project module.
 */

use Drupal\block\Entity\Block;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;

/**
 * Implements hook_install().
 */
function platformsh_project_install() {
  \Drupal::messenger()->addStatus(__FUNCTION__ . " is installing content definitions from its yaml configs");
  // The creation of all content types and fields is managed by config/install.
  // Creating content types programatically here is tedious,
  // Yaml definitions are fine, as long as we keep the dependencies aligned
  // I would also like to do this for views and block placements
  // BUT yaml configs get imported AFTER this hook runs.
  // Which makes it hard for me to configure a block
  //  which depends on a view
  //  that's not yet been created.

  // I also want to place our admin blocks at install time into the current theme.
  // But doing that via yamls will hard-code the theme ID. No good.

  // Solution,. a hybrid approach - import some yamls manually now,
  // from the `config/preinstall folder.
  // Manipulate some things.
  // let the system import the rest of the normal yamls next.

  // Obtain configuration from yaml files
  $config_folder = \Drupal::service('extension.list.module')->getPath('platformsh_project') . '/config/preinstall/';

  // Install the views, so we can have a views_block, so we can position it.
  $view_config_ids = [
    'views.view.platformsh_node_actions',
    'views.view.platformsh_metrics_actions',
    'views.view.platformsh_references',
    'views.view.platformsh_metrics_references',
  ];
  foreach ($view_config_ids as $config_id) {
    $data = \Symfony\Component\Yaml\Yaml::parseFile($config_folder . $config_id . '.yml');
    \Drupal::configFactory()
      ->getEditable($config_id)
      ->setData($data)
      ->save(TRUE);
    \Drupal::messenger()->addStatus(__FUNCTION__ . " installed " . $config_id);
  }

  // Place block instances by code.
  //
  // Take a short cut by loading the config yaml, manipulating it slightly, then saving it.
  // This means we can recycle all the tedious irrelevant settings in yamls
  // and not bother too much with CRUD and entity creation.
  // The config save does all the heavy lifting

  // Note the difference between a block definition (available blocks)
  // and a block config instance - a "block" that is placed in a region.
  // We need to "create" a new block instance (config object)
  // in order to place a defined block in a defined place.
  // Need to do al this just to soft-code the current theme.
  // If theme could have been `%current_theme%` then we'd have been cool.
  $theme_name = \Drupal::service('theme.manager')->getActiveTheme()->getName();

  // Fetch a pre-exported yaml from our pre-install folder,
  // and tweak it before import..
  $block_config_ids = [
    'block.block.platformsh_metrics_actions_block',
    'block.block.platformsh_project_actions_block',
    'block.block.platformsh_organization_actions_block',
    'block.block.platformsh_references_project_list_block',
    'block.block.platformsh_metrics_references_table_block',
    ];
  foreach ($block_config_ids as $config_id) {
    $data = \Symfony\Component\Yaml\Yaml::parseFile($config_folder . $config_id .'.yml');
    $data['theme'] = $theme_name;
    \Drupal::configFactory()->getEditable($config_id)->setData($data)->save(TRUE);
  }
  \Drupal::messenger()->addStatus(__FUNCTION__ . " placed actions blocks on some entity pages for admin purposes.");

  // Another hybrid yaml import.
  // It seems near impossible to find instructions for how to define
  // normal editable fields from code. Entity BaseFields are not normal.
  // So load up the yaml definitions for the fields that we want on entities
  // and import them.

  // Field storage
  $config_id = 'field.storage.metric.requirement';
  $data = \Symfony\Component\Yaml\Yaml::parseFile($config_folder . $config_id .'.yml');
  \Drupal::configFactory()->getEditable($config_id)->setData($data)->save(TRUE);
  // Field bundle instance
  $config_id = 'field.field.metric.bundle.requirement';
  $data = \Symfony\Component\Yaml\Yaml::parseFile($config_folder . $config_id .'.yml');
  $metric_types = ['note'];
  foreach ($metric_types as $bundle) {
    $local_config_id = 'field.field.metric.' . $bundle . '.requirement';
    $data['id'] = 'metric.' . $bundle . '.requirement';
    $data['bundle'] = $bundle;
    \Drupal::configFactory()->getEditable($local_config_id)->setData($data)->save(TRUE);
    \Drupal::messenger()->addStatus(__FUNCTION__ . " Added a requirement field to the " . $bundle . " metric.");
  }

  platformsh_project_update_fields();
}

// deprecated notes
function install_extra() {
  // Define field storage by code.
  // Can also be done with yamls, but see if doing it with code is more manageable.
  /** @var \Drupal\Core\Entity\EntityFieldManagerInterface $field_manager */
  $field_manager = \Drupal::service('entity_field.manager');
  /** @var \Drupal\Core\Field\FieldStorageDefinitionListener $field_storage_manager */
  $field_storage_manager = \Drupal::service('field_storage_definition.listener');

  $field_info = [
    'type' => 'entity_reference_revisions',
    'entity_type' => 'metric',
    'field_name' => 'requirement',
    'bundle' => 'note',
    'label' => t('Requirements')
  ];
  $field_storage = platformsh_project_createEntityFieldStorage($field_info);
  $fields['requirement'] = FieldConfig::create($field_info);

  $entity_definition = $field_manager->getFieldStorageDefinitions('metric')['drupalcache'];
  // Make sure these are all saved and configured,
  // Ensure there is a storage schema for all our fields.
  $field_storage_manager->onFieldStorageDefinitionCreate($entity_definition);
}

/**
 * Implements hook_preuninstall().
 *
*/
function platformsh_project_uninstall(){
  platformsh_project_module_preuninstall('platformsh_project');

  // TODO: our custom placed blocks from config/preinstall
  // don't seem to be removing themselves on uninstall().
  // even though the configs should claim `dependencies:enforced`
  $block_storage = \Drupal::service('entity_type.manager')->getStorage('block');
  /** @var \Drupal\block\Entity\Block[] $blocks */
  $blocks = $block_storage->loadMultiple();
  foreach ($blocks as $block) {
    // delete ours
  }
}



// Trigger a config update if actions are added.
/*
function platformsh_project_update_8001() {
  $config_installer = \Drupal::service('config.installer');
  $config_installer->installDefaultConfig('module', 'platformsh_project');
}
*/


