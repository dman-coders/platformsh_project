<?php

/**
 * @file
 * Primary module hooks for platformsh_project module.
 */

use Drupal\Core\Field\BaseFieldDefinition;

/**
 * hook_entity_bundle_info_alter is how we attach a custom Class
 * to handle our entity definition.
 * That would otherwise be just a vanilla system-managed object.
 *
 * We still allow most of that methods and properties of a core ContentEntityBase,
 * as our classes inherit from that.
 *
 * @param array $bundles
 *
 * @return void
 */
function platformsh_project_entity_bundle_info_alter(array &$bundles): void {
  if (isset($bundles['node']['project'])) {
    // Possible since 9.3 https://www.drupal.org/project/drupal/issues/2570593
    $bundles['node']['project']['class'] = \Drupal\platformsh_project\Entity\Project::class;
  }
  if (isset($bundles['node']['user'])) {
    $bundles['node']['user']['class'] = \Drupal\platformsh_project\Entity\User::class;
  }
  if (isset($bundles['node']['organization'])) {
    $bundles['node']['organization']['class'] = \Drupal\platformsh_project\Entity\Organization::class;
  }
  if (isset($bundles['metric']['note'])) {
    $bundles['metric']['note']['class'] = \Drupal\platformsh_project\Entity\NoteMetric::class;
  }
  if (isset($bundles['metric']['ping'])) {
    $bundles['metric']['ping']['class'] = \Drupal\platformsh_project\Entity\PingMetric::class;
  }
  if (isset($bundles['metric']['drupalcache'])) {
    $bundles['metric']['drupalcache']['class'] = \Drupal\platformsh_project\Entity\DrupalCacheMetric::class;
  }
}


/**
 * Implements hook_ENTITY_TYPE_presave() for node entities.
 *
 * Synchronises a project entry with API info on first creation.
 * See also hook_ENTITY_TYPE_create - this may be what I mean to use sometimes.
 */
function platformsh_project_node_presave(Drupal\Node\Entity\Node $entity) {
  // Update from API if brand new
  if ($entity->getType() == 'project' && $entity->isNew()) {
    \Drupal::logger('platformsh_project')->notice("Creating a new project");
    $action = \Drupal::entityTypeManager()
      ->getStorage('action')
      ->load('platformsh_project_refresh_from_api_action');
    if ($action) {
      $action->execute([$entity]);
    }
  }
  // Ensure target entities exist if references to org or owner are set.
  $api_service = \Drupal::service('platformsh_api.fetcher');
  $referrees = [];
}

/**
 * Delete all nodes of content types defined by this module,
 * the content type definitions,
 * and their field storage definitions.
 *
 * Implements hook_module_preuninstall().
 *
 * Note, it appears that `hook_module_preuninstall()`
 * cannot be placed in the {module}.install file.
 * It is .. uncertain when this gets invoked in practice.
 *
 * Arg! This gets called any time ANYTHING is uninstalled!
 * Danger. Maybe this is not the right place to be invoking this.
 * maybe it's hook_uninstall after all.
 */
function platformsh_project_module_preuninstall($module): void {
  if ('platformsh_project' !== $module) {
    return;
  }
  $content_type_names = ['project','user','organization'];

  \Drupal::messenger()->addStatus(__FUNCTION__ . " is deleting all content associated with its content types: " . implode(', ', $content_type_names));

  foreach ($content_type_names as $content_type_name) {
    $storage_handler = \Drupal::entityTypeManager()
      ->getStorage('node');
    $nodes = $storage_handler->loadByProperties(['type' => $content_type_name]);
    $storage_handler->delete($nodes);
  }
  // To ensure that our content type definitions and field definitions
  // associated with this module go away also, add
  // `dependencies:enforced:module:platformsh_project`
  // To every `field.storage.node.*.yml` file in `config/install`
  // Otherwise they will remain behind as orphaned fields,
  // and conflict if you try to re-install this module.

  \Drupal::messenger()->addStatus(__FUNCTION__ . " is deleting all metrics.");

  $entity_type_names = ['metric'];
  foreach ($entity_type_names as $entity_type) {
    $storage_handler = \Drupal::entityTypeManager()
      ->getStorage($entity_type);
    $entities = $storage_handler->loadByProperties([]);
    $storage_handler->delete($entities);
  }

}

/**
 * Implements hook_help().
 */
function platformsh_project_help($route_name, \Drupal\Core\Routing\RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Drop some dev notes in here
    case 'metric.add_unknown_metric_to_project':
      return 'DEV: add_unknown_metric_to_project';
    case 'metric.add_known_metric_to_project':
      return 'DEV: add_known_metric_to_project';
  }
  return 'DEV: ' .  $route_name;
}

function platformsh_project_entity_bundle_field_info(\Drupal\Core\Entity\EntityTypeInterface $entity_type, $bundle, array $base_field_definitions) {
  return null;

  // Add a property to all metric entities.
  if ($entity_type->id() == 'metric') {
    $fields = array();
    $fields['requirement'] =
    BaseFieldDefinition::create('entity_reference_revisions')
      ->setLabel(t('Requirements'))
      ->setSetting('target_type', 'paragraph')
      ->setSetting('handler', 'default:paragraph')
      ->setSetting('handler_settings', [
        'target_bundles' => ['requirement' => 'requirement'],
      ])
      ->setCardinality(-1)
      ->setTargetBundle(null)
      ->setRequired(false)
      ->setDisplayOptions('view', [
        'type' => 'paragraphs_table_formatter',
        'label' => 'above',
        'weight' => 5,
        'region' => 'content',
        'settings' => [
          'view_mode' => 'default',
          'vertical' => false,
          'caption' => '',
          'mode' => '',

        ],
      ]);

    return $fields;
  }
}

/**
 * Utility function for finding projects.
 *
 * @param $project_id
 *
 * @return null | \Drupal\node\Entity\Node
 */
function platformsh_project_get_project_by_project_id($project_id){
  $nodes = \Drupal::entityTypeManager()
    ->getStorage('node')
    ->loadByProperties([
      'field_id' => $project_id,
    ]);
  if ($node = reset($nodes)) {
    return $node;
  }
  \Drupal::messenger()->addStatus(__FUNCTION__ . " failed to find a project with the ID " . $project_id);
  return null;

}
