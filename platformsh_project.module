<?php

/**
 * @file
 * Primary module hooks for platformsh_project module.
 */

use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Entity\EntityTypeInterface as EntityTypeInterfaceAlias;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Field\FieldDefinition;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\platformsh_project\Entity\DrupalCacheMetric;
use Drupal\platformsh_project\Entity\NoteMetric;
use Drupal\platformsh_project\Entity\Organization;
use Drupal\platformsh_project\Entity\PingMetric;
use Drupal\platformsh_project\Entity\Project;
use Drupal\platformsh_project\Entity\User;
use Symfony\Component\Yaml\Yaml;

/**
 * hook_entity_bundle_info()
 *
 * https://www.drupal.org/node/3191609
 * An alternative to declaring everything in yaml files.
 *
 * @param array $bundles
 *
 * @return array

 */
function platformsh_project_entity_bundle_info(): array {
  $bundles['metric']['pong']['label'] = t('A Pong!');
  $bundles['metric']['pong']['class'] = PingMetric::class;

  $bundles['metric']['fastly'] = [
    'label' => t('Check Fastly status'),
    'class' =>  Drupal\platformsh_project\Entity\FastlyMetric::class
  ];

  return $bundles;
}

/**
 * @implements hook_entity_type_alter()
 * @return void
 */
function platformsh_project_entity_type_alter(&$entity_info): void {
  // Adjust the bundle definitions after the annotatiuons have been read.
}

/**
 * hook_entity_bundle_info_alter is how we attach a custom Class
 * to handle our entity definition.
 * That would otherwise be just a vanilla system-managed object.
 *
 * We still allow most of that methods and properties of a core
 * ContentEntityBase, as our classes inherit from that.
 *
 * @param array $bundles
 *
 * @return void
 */
function platformsh_project_entity_bundle_info_alter(array &$bundles): void {
  if (isset($bundles['node']['project'])) {
    // Possible since 9.3 https://www.drupal.org/project/drupal/issues/2570593
    $bundles['node']['project']['class'] = Project::class;
  }
  if (isset($bundles['node']['user'])) {
    $bundles['node']['user']['class'] = User::class;
  }
  if (isset($bundles['node']['organization'])) {
    $bundles['node']['organization']['class'] = Organization::class;
  }
  /*
  if (isset($bundles['metric']['note'])) {
    $bundles['metric']['note']['class'] = NoteMetric::class;
  }
  if (isset($bundles['metric']['ping'])) {
    $bundles['metric']['ping']['class'] = PingMetric::class;
  }
  if (isset($bundles['metric']['drupalcache'])) {
    $bundles['metric']['drupalcache']['class'] = DrupalCacheMetric::class;
  }
  */
  // Find all metric bundle classes, and make sure they are registered as expected.
  $entities = Drupal::entityTypeManager()->getDefinitions();
  foreach ($entities as $entity_definition) {
    if ($entity_definition->getBundleEntityType() == 'metric_type') {
      $bundles['metric'][$entity_definition->id()]['class'] = $entity_definition->getClass();
      $bundles['metric'][$entity_definition->id()]['label'] = $entity_definition->getLabel();
    }
  }
}

/**
 * Implements hook_entity_field_storage_info()
 *
 * Defines storage for all bundle fields that were defined in
 * bundle-specific bundleFieldDefinitions()
 */
function platformsh_project_entity_field_storage_info(EntityTypeInterface $entity_type) {
  if ($entity_type->id() == 'metric') {
    $definitions = [];
    $bundles = \Drupal::service('entity_type.bundle.info')->getBundleInfo('metric');
    foreach ($bundles as $bundle_id=>$bundle_info) {
      if (isset($bundle_info['class'])) {
        $class = '\\'.$bundle_info['class'];
        if (class_exists($class)) {
          $bundle_defs = $class::bundleFieldDefinitions($entity_type, $bundle_id, []);
          array_merge($definitions, $bundle_defs);
        }
      }
    }
    return $definitions;
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave() for node entities.
 *
 * Synchronises a project entry with API info on first creation.
 * See also hook_ENTITY_TYPE_create - this may be what I mean to use sometimes.
 */
function platformsh_project_node_presave(Drupal\Node\Entity\Node $entity) {
  // Update from API if brand new
  if ($entity->getType() == 'project' && $entity->isNew()) {
    Drupal::logger('platformsh_project')->notice("Creating a new project");
    $action = Drupal::entityTypeManager()
      ->getStorage('action')
      ->load('platformsh_project_refresh_from_api_action');
    if ($action) {
      $action->execute([$entity]);
    }
  }
  // Ensure target entities exist if references to org or owner are set.
  $api_service = Drupal::service('platformsh_api.fetcher');
  $referrees = [];
}

/**
 * Delete all nodes of content types defined by this module,
 * the content type definitions,
 * and their field storage definitions.
 *
 * Implements hook_module_preuninstall().
 *
 * Note, it appears that `hook_module_preuninstall()`
 * cannot be placed in the {module}.install file.
 * It is .. uncertain when this gets invoked in practice.
 *
 */
function platformsh_project_module_preuninstall($module): void {
  // This gets called any time ANYTHING is uninstalled!
  // Danger. Maybe this is not the right place to be invoking this.
  // maybe it's hook_uninstall after all.
  if ('platformsh_project' !== $module) {
    return;
  }

  $content_type_names = ['project', 'user', 'organization'];

  Drupal::messenger()
    ->addStatus(__FUNCTION__ . " is deleting all content associated with its content types: " . implode(', ', $content_type_names));

  foreach ($content_type_names as $content_type_name) {
    $storage_handler = Drupal::entityTypeManager()
      ->getStorage('node');
    $nodes = $storage_handler->loadByProperties(['type' => $content_type_name]);
    $storage_handler->delete($nodes);
  }
  // To ensure that our content type definitions and field definitions
  // associated with this module go away also, add
  // `dependencies:enforced:module:platformsh_project`
  // To every `field.storage.node.*.yml` file in `config/install`
  // Otherwise they will remain behind as orphaned fields,
  // and conflict if you try to re-install this module.

  platformsh_project_delete_all_metrics();

}

function platformsh_project_delete_all_metrics() {
  Drupal::messenger()->addStatus(__FUNCTION__ . " is deleting all metrics.");
  $entity_type_names = ['metric'];
  foreach ($entity_type_names as $entity_type) {
    $storage_handler = Drupal::entityTypeManager()
      ->getStorage($entity_type);
    $entities = $storage_handler->loadByProperties([]);
    $storage_handler->delete($entities);
  }
  /*
  $entity_type_names = ['paragraph'];
  foreach ($entity_type_names as $entity_type) {
    $storage_handler = Drupal::entityTypeManager()
      ->getStorage($entity_type);
    $entities = $storage_handler->loadByProperties([]);
    $storage_handler->delete($entities);
  }
  */

}

/**
 * Implements hook_help().
 */
function platformsh_project_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Drop some dev notes in here
    case 'metric.add_unknown_metric_to_project':
      return 'DEV: add_unknown_metric_to_project';
    case 'metric.add_known_metric_to_project':
      return 'DEV: add_known_metric_to_project';
  }
  return 'DEV: ' . $route_name;
}


/**
 * Utility function for finding projects.
 *
 * @param $project_id
 *
 * @return null | \Drupal\node\Entity\Node
 */
function platformsh_project_get_project_by_project_id($project_id) {
  $nodes = Drupal::entityTypeManager()
    ->getStorage('node')
    ->loadByProperties([
      'field_id' => $project_id,
    ]);
  if ($node = reset($nodes)) {
    return $node;
  }
  Drupal::messenger()
    ->addStatus(__FUNCTION__ . " failed to find a project with the ID " . $project_id);
  return NULL;

}


/**
 * Update the fields that are attached to metrics
 *
 * It seems near impossible to manually and confidently
 * create and attach fields via code using FieldStorageConfig::create()
 * and the rest.
 * It seems that setting up our content types with baseFieldDefinitions()
 * is problematic, and base fields don't play well with FieldUI fields.
 *
 * Trying to add fields with
 * hook_entity_field_storage_info(), hook_entity_bundle_field_info()
 * May have been correct, but triggered a lot of site-killer errors
 * if mysterious things don't align correctly.
 * Incredibly fragile, opaque and broken.
 *
 * ALL the tutorials say to just export and use yamls for this, but this
 * doesn't scale well because we have to keep adding and maintaining yamls
 * for each metric bundle.
 *
 * So this is a hybrid.
 * Define the fields in yamls, but don't just install them.
 * Load the yamls as templates.
 * Tweak the template, then import the config.
 * Allow the field UI to work with them while it all gets set up.
 * Allow re-importing of these yamls to reset them
 *
 * We selectively grab yamls out of the /config/preinstall/
 * folder, then config-import them.
 */
function platformsh_project_update_fields() {

  // Obtain configuration from yaml files
  $config_folder = Drupal::service('extension.list.module')
      ->getPath('platformsh_project') . '/config/preinstall/';

  // 'REQUIREMENT' definition.
  // A paragraph field collection.
  // The paragraph entity definition itself is already defined wiith normal install yamls.

  // Field storage
  $config_id = 'field.storage.metric.requirement';
  $data = Yaml::parseFile($config_folder . $config_id . '.yml');
  Drupal::configFactory()->getEditable($config_id)->setData($data)->save(TRUE);

  // Field bundle instance
  $config_id = 'field.field.metric.bundle.requirement';
  $data = Yaml::parseFile($config_folder . $config_id . '.yml');
  $metric_types = ['note', 'ping', 'drupalcache'];
  foreach ($metric_types as $bundle_id) {
    $local_config_id = 'field.field.metric.' . $bundle_id . '.requirement';
    $data['id'] = 'metric.' . $bundle_id . '.requirement';
    $data['bundle'] = $bundle_id;
    Drupal::configFactory()
      ->getEditable($local_config_id)
      ->setData($data)
      ->save(TRUE);

    // Also have to define the view and form layouts,
    // or the field won't show up.
    // core.entity_form_display.metric.bundle.default.yml
    // core.entity_view_display.metric.bundle.default.yml
    foreach (['entity_form_display', 'entity_view_display'] as $display_mode) {
      $local_config_id = 'core.' . $display_mode . '.metric.' . $bundle_id . '.default';
      $data['id'] = 'metric.' . $bundle_id . '.default';
      $data['bundle'] = $bundle_id;
      $data['dependencies']['config'] = [
        'field.field.metric.' . $bundle_id . '.requirement',
        'platformsh_project.metric_type.' . $bundle_id,
      ];
      Drupal::configFactory()
        ->getEditable($local_config_id)
        ->setData($data)
        ->save(TRUE);
      // TODO
      // maybe adjust this yaml import so that is just patches the config
      // with the field display settings, not override the whole thing.
      $confirm_config = Drupal::configFactory()
        ->getEditable($local_config_id);

    }

    \Drupal::logger('platformsh_project')->info("%provenance: Added a requirement field to the %metric_type metric.", ['%provenance' => __FUNCTION__ ,'%metric_type' => $bundle_id] );
    \Drupal::messenger()
      ->addStatus(__FUNCTION__ . " Added a requirement field to the " . $bundle_id . " metric.");
  }

  // Yamls are a silly way to manage fields that should be getting declared by code in the classes.
  // So check the bundle classes and declare their fields.
  // https://www.drupal.org/docs/create-custom-content-types-with-bundle-classes

  $efm = \Drupal::service('entity_field.manager');
  $entity_type_id = 'metric';
  $bundle_id = 'fastly';
  $base_fields = $efm->getFieldStorageDefinitions($entity_type_id, $bundle_id);
  // This gets all fields defined for the bundle, including base fields.
  $type_fields = $efm->getFieldDefinitions($entity_type_id, $bundle_id);
  // This gets us the list of fields defined by the bundle.
  $bundle_fields = array_diff(array_keys($type_fields), array_keys($base_fields));
  foreach ($bundle_fields as $id => $field_name) {
    \Drupal::entityDefinitionUpdateManager()->installFieldStorageDefinition(
      $field_name,
      $entity_type_id,
      'platformsh_project',
      $type_fields[$field_name]
    );
    \Drupal::messenger()
      ->addStatus(__FUNCTION__ . " Added custom field " . $field_name . " to the " . $bundle_id . " metric.");
  }


}

